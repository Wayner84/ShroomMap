<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liberty Cap Habitat Suitability Map - UK</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        /* Inline styles for self-contained file */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --color-ideal: #2ecc71;
            --color-ideal-border: #1b7f4b;
            --color-caution: #ffb74d;
            --color-caution-border: #c77800;
            --color-poor: #ff5a5f;
            --color-poor-border: #b71c1c;
            --color-average: #7bb0ff;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        #app {
            display: flex;
            height: 100vh;
            position: relative;
        }

        .sidebar {
            width: 320px;
            background: linear-gradient(135deg, #2d4a22 0%, #1a2f15 100%);
            border-right: 2px solid #4a6b3a;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            box-shadow: 2px 0 20px rgba(0,0,0,0.3);
        }

        .sidebar.collapsed {
            transform: translateX(-280px);
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar-header h2 {
            color: #a8d48a;
            font-size: 1.4em;
            font-weight: 600;
        }

        .toggle-btn {
            background: #4a6b3a;
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
        }

        .toggle-btn:hover {
            background: #5a7b4a;
            transform: scale(1.05);
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 0 0 20px 0;
        }

        .section {
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .section h3 {
            color: #c5e6a8;
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .weight-control, .threshold-control, .weather-control {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
            gap: 8px;
        }

        .weight-control label, .threshold-control label, .weather-control label {
            font-size: 0.9em;
            color: #b8d49a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .weight-value {
            background: rgba(168, 212, 138, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.8em;
            min-width: 45px;
            text-align: center;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #4a6b3a 0%, #2d4a22 100%);
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #a8d48a;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }

        input[type="number"], input[type="password"], select {
            background: rgba(0,0,0,0.3);
            border: 1px solid #4a6b3a;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9em;
        }

        .layer-control {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .layer-control label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.9em;
            color: #b8d49a;
        }

        .layer-control input[type="checkbox"] {
            margin-right: 8px;
            accent-color: #a8d48a;
        }

        .refresh-btn {
            width: 100%;
            background: linear-gradient(135deg, #4a6b3a 0%, #5a7b4a 100%);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .refresh-btn:hover {
            background: linear-gradient(135deg, #5a7b4a 0%, #6a8b5a 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }

        .legend {
            background: rgba(0,0,0,0.25);
            padding: 20px;
            border-top: 1px solid rgba(255,255,255,0.05);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .legend h3 {
            color: #c5e6a8;
            margin-bottom: 0;
        }

        .legend-description {
            font-size: 0.8em;
            color: #9fb78b;
            line-height: 1.4;
        }

        .legend-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            font-size: 0.9em;
        }

        .legend-item strong {
            display: block;
            color: #e0f2f1;
            margin-bottom: 2px;
        }

        .legend-detail {
            font-size: 0.75em;
            color: #b8d49a;
            opacity: 0.9;
        }

        .legend-swatch {
            width: 26px;
            height: 26px;
            border-radius: 8px;
            border: 2px solid;
            box-shadow: 0 0 12px rgba(0,0,0,0.35);
            flex-shrink: 0;
        }

        .legend-swatch.legend-ideal {
            background: var(--color-ideal);
            border-color: rgba(27, 127, 75, 0.85);
            box-shadow: 0 0 18px rgba(46, 204, 113, 0.4);
        }

        .legend-swatch.legend-caution {
            background: var(--color-caution);
            border-color: rgba(199, 120, 0, 0.8);
            box-shadow: 0 0 18px rgba(255, 183, 77, 0.35);
        }

        .legend-swatch.legend-poor {
            background: var(--color-poor);
            border-color: rgba(183, 28, 28, 0.8);
            box-shadow: 0 0 18px rgba(255, 90, 95, 0.35);
        }

        .spinner {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            color: #a8d48a;
            font-size: 0.9em;
        }

        .spinner::before {
            content: '';
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top: 2px solid #a8d48a;
            border-radius: 50%;
            margin-right: 8px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden { display: none !important; }

        .map-container {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        #map {
            flex: 1;
            background: #1a1a1a;
            min-height: 400px;
        }

        .status-bar {
            background: linear-gradient(135deg, #2d2d2d 0%, #1a1a1a 100%);
            padding: 12px 20px;
            border-top: 1px solid #404040;
            font-size: 0.85em;
            color: #cfd8dc;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 12px;
        }

        #statusText {
            flex: 1;
            min-width: 220px;
        }

        .status-metrics {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .status-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 999px;
            border: 1px solid transparent;
            font-size: 0.78em;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            font-weight: 600;
            background: rgba(255,255,255,0.05);
            white-space: nowrap;
        }

        .status-chip strong {
            font-size: 1.1em;
            color: inherit;
        }

        .status-chip .chip-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            box-shadow: 0 0 8px currentColor;
        }

        .status-chip.average {
            background: rgba(123, 176, 255, 0.18);
            border-color: rgba(123, 176, 255, 0.5);
            color: #9ec5ff;
        }

        .status-chip.ideal {
            background: rgba(46, 204, 113, 0.18);
            border-color: rgba(27, 127, 75, 0.6);
            color: #80f7b3;
        }

        .status-chip.caution {
            background: rgba(255, 183, 77, 0.2);
            border-color: rgba(199, 120, 0, 0.6);
            color: #ffd59a;
        }

        .status-chip.poor {
            background: rgba(255, 90, 95, 0.18);
            border-color: rgba(183, 28, 28, 0.6);
            color: #ffb3b6;
        }

        .popup-content {
            font-size: 0.85em;
        }

        .popup-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
        }

        .popup-header strong {
            font-size: 1em;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            color: #e8f5e9;
        }

        .popup-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 9px;
            border-radius: 999px;
            border: 1px solid transparent;
            font-size: 0.7em;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            font-weight: 600;
        }

        .popup-badge .badge-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
            box-shadow: 0 0 8px currentColor;
        }

        .popup-badge.ideal {
            background: rgba(46, 204, 113, 0.15);
            border-color: rgba(27, 127, 75, 0.45);
            color: #81f7b3;
        }

        .popup-badge.caution {
            background: rgba(255, 183, 77, 0.15);
            border-color: rgba(199, 120, 0, 0.45);
            color: #ffd59a;
        }

        .popup-badge.poor {
            background: rgba(255, 90, 95, 0.15);
            border-color: rgba(183, 28, 28, 0.45);
            color: #ffb3b6;
        }

        .popup-score {
            margin-bottom: 14px;
        }

        .score-number {
            font-size: 1.8em;
            font-weight: 700;
            color: #ffffff;
        }

        .score-bar {
            width: 100%;
            height: 8px;
            border-radius: 999px;
            background: rgba(255,255,255,0.08);
            margin: 6px 0 4px;
            overflow: hidden;
        }

        .score-fill {
            height: 100%;
            border-radius: inherit;
        }

        .score-fill.ideal { background: var(--color-ideal); }
        .score-fill.caution { background: var(--color-caution); }
        .score-fill.poor { background: var(--color-poor); }

        .score-caption {
            font-size: 0.75em;
            color: #b8d49a;
            line-height: 1.4;
        }

        .popup-section {
            margin-bottom: 12px;
        }

        .popup-section strong {
            display: block;
            margin-bottom: 6px;
            color: #e0e0e0;
        }

        .popup-section small {
            color: #c7c7c7;
            line-height: 1.5;
            display: block;
        }

        .popup-warning {
            padding: 8px 10px;
            border-radius: 6px;
            background: rgba(255, 90, 95, 0.15);
            border: 1px solid rgba(183, 28, 28, 0.45);
            color: #ffb3b6;
            font-size: 0.78em;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .disclaimer {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            color: #ffa726;
            padding: 15px 20px;
            border-radius: 10px;
            max-width: 400px;
            font-size: 0.85em;
            line-height: 1.4;
            border: 1px solid #ff9800;
            backdrop-filter: blur(10px);
            z-index: 2000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .error-message {
            background: #d32f2f;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        .info-message {
            background: #1976d2;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        /* Leaflet popup styling */
        .leaflet-popup-content-wrapper {
            background: #2d2d2d !important;
            color: #e0e0e0 !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5) !important;
        }

        .leaflet-popup-tip {
            background: #2d2d2d !important;
        }

        .leaflet-control-layers {
            background: #2d2d2d !important;
            color: #e0e0e0 !important;
            border: 1px solid #4a6b3a !important;
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 280px;
            }
            .disclaimer {
                position: relative;
                bottom: auto;
                right: auto;
                margin: 10px;
                max-width: none;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h2>Habitat Analysis</h2>
                <button id="toggleSidebar" class="toggle-btn">←</button>
            </div>
            
            <div class="sidebar-content">
                <div class="section">
                    <button id="refreshData" class="refresh-btn">🔄 Refresh Data</button>
                    <div id="loadingSpinner" class="spinner hidden">Loading...</div>
                    <div id="errorMessage" class="error-message hidden"></div>
                    <div id="infoMessage" class="info-message hidden"></div>
                </div>

                <div class="section">
                    <h3>Factor Weights</h3>
                    <div class="weight-control">
                        <label for="landcoverWeight">Land Cover (0.30)</label>
                        <input type="range" id="landcoverWeight" min="0" max="0.4" step="0.01" value="0.30">
                        <span class="weight-value">0.30</span>
                    </div>
                    <div class="weight-control">
                        <label for="phWeight">Soil pH (0.25)</label>
                        <input type="range" id="phWeight" min="0" max="0.4" step="0.01" value="0.25">
                        <span class="weight-value">0.25</span>
                    </div>
                    <div class="weight-control">
                        <label for="drainWeight">Drainage (0.15)</label>
                        <input type="range" id="drainWeight" min="0" max="0.4" step="0.01" value="0.15">
                        <span class="weight-value">0.15</span>
                    </div>
                    <div class="weight-control">
                        <label for="grazeWeight">Grazing (0.10)</label>
                        <input type="range" id="grazeWeight" min="0" max="0.4" step="0.01" value="0.10">
                        <span class="weight-value">0.10</span>
                    </div>
                    <div class="weight-control">
                        <label for="terrainWeight">Terrain (0.05)</label>
                        <input type="range" id="terrainWeight" min="0" max="0.4" step="0.01" value="0.05">
                        <span class="weight-value">0.05</span>
                    </div>
                    <div class="weight-control">
                        <label for="climateWeight">Climate (0.15)</label>
                        <input type="range" id="climateWeight" min="0" max="0.4" step="0.01" value="0.15">
                        <span class="weight-value">0.15</span>
                    </div>
                </div>

                <div class="section">
                    <h3>Rain Thresholds (mm)</h3>
                    <div class="threshold-control">
                        <label for="minRain">Minimum ideal rain (8)</label>
                        <input type="number" id="minRain" min="0" max="50" value="8">
                    </div>
                    <div class="threshold-control">
                        <label for="maxRain">Maximum ideal rain (35)</label>
                        <input type="number" id="maxRain" min="0" max="100" value="35">
                    </div>
                </div>

                <div class="section">
                    <h3>Data Settings</h3>
                    <div class="weather-control">
                        <label for="weatherSource">Weather API:</label>
                        <select id="weatherSource">
                            <option value="open-meteo">Open-Meteo (Free)</option>
                            <option value="met-office">Met Office DataHub</option>
                        </select>
                    </div>
                    <div class="weather-control" id="apiKeyControl" style="display: none;">
                        <label for="metOfficeKey">Met Office API Key:</label>
                        <input type="password" id="metOfficeKey" placeholder="Enter API key">
                    </div>
                    <div class="weather-control">
                        <label for="soilDataSource">Soil Data:</label>
                        <select id="soilDataSource">
                            <option value="soilgrids">SoilGrids (ISRIC)</option>
                            <option value="ukso">UK Soil Observatory</option>
                        </select>
                    </div>
                    <div class="weather-control">
                        <label for="landcoverSource">Land Cover:</label>
                        <select id="landcoverSource">
                            <option value="esa-worldcover">ESA WorldCover</option>
                            <option value="corine">Copernicus CORINE</option>
                        </select>
                    </div>
                </div>

                <div class="section">
                    <h3>Data Layers</h3>
                    <div class="layer-control">
                        <label><input type="checkbox" id="showSuitability" checked> Suitability Grid</label>
                    </div>
                    <div class="layer-control">
                        <label><input type="checkbox" id="showLandcover"> Land Cover Layer</label>
                    </div>
                    <div class="layer-control">
                        <label><input type="checkbox" id="showRainfall"> Rainfall Heatmap</label>
                    </div>
                    <div class="layer-control">
                        <label><input type="checkbox" id="showSoil"> Soil Properties</label>
                    </div>
                </div>

                <div class="legend">
                    <h3>Suitability legend</h3>
                    <p class="legend-description">Colours highlight habitat readiness at a glance. Rainfall and the combined score determine which band a cell belongs to.</p>
                    <div class="legend-item">
                        <span class="legend-swatch legend-ideal"></span>
                        <div>
                            <strong>Prime habitat</strong>
                            <div class="legend-detail">Score ≥ 0.70 with 72&nbsp;h rainfall in the sweet spot</div>
                        </div>
                    </div>
                    <div class="legend-item">
                        <span class="legend-swatch legend-caution"></span>
                        <div>
                            <strong>Dry but promising</strong>
                            <div class="legend-detail">Base metrics are solid but more rainfall is needed</div>
                        </div>
                    </div>
                    <div class="legend-item">
                        <span class="legend-swatch legend-poor"></span>
                        <div>
                            <strong>Unfavourable</strong>
                            <div class="legend-detail">Score &lt; 0.50 or waterlogging limits fruiting</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="mapContainer" class="map-container">
            <div id="map"></div>
            <div id="statusBar" class="status-bar">
                <span id="statusText">Initializing map...</span>
                <div class="status-metrics">
                    <span class="status-chip average">Avg score <strong id="avgScoreChip">0.00</strong></span>
                    <span class="status-chip ideal"><span class="chip-dot"></span>Prime <strong id="idealCount">0</strong></span>
                    <span class="status-chip caution"><span class="chip-dot"></span>Needs rain <strong id="cautionCount">0</strong></span>
                    <span class="status-chip poor"><span class="chip-dot"></span>Unfavourable <strong id="poorCount">0</strong></span>
                </div>
            </div>
        </div>
    </div>

    <div id="disclaimer" class="disclaimer">
        <p><strong>Educational Use Only:</strong> This tool models habitat suitability based on environmental factors. 
        Always verify mushroom identification with experts and check local foraging regulations before collecting.</p>
    </div>

    <!-- Load external libraries -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    
    <script>
        // Main application class
        class LibertyCapsHabitatMap {
            constructor() {
                this.map = null;
                this.gridLayer = null;
                this.overlayLayers = new Map();
                
                this.weights = {
                    landcover: 0.30,
                    ph: 0.25,
                    drainage: 0.15,
                    grazing: 0.10,
                    terrain: 0.05,
                    climate: 0.15
                };
                
                this.rainThresholds = { min: 8, max: 35 };
                this.gridSize = 0.05; // ~5km grid
                this.ukBounds = [[49.5, -8.5], [61.0, 2.0]]; // UK bounding box
                
                this.gridCells = new Map();
                this.weatherCache = new Map();
                this.soilCache = new Map();
                this.landcoverCache = new Map();

                this.categoryStyles = {
                    ideal: {
                        fill: '#2ecc71',
                        border: '#1b7f4b',
                        label: 'Prime habitat',
                        description: 'Score meets the target and rainfall is supportive.'
                    },
                    caution: {
                        fill: '#ffb74d',
                        border: '#c77800',
                        label: 'Needs rain',
                        description: 'Baseline looks good but recent rain is below the trigger window.',
                        dashArray: '6 4'
                    },
                    poor: {
                        fill: '#ff5a5f',
                        border: '#b71c1c',
                        label: 'Unfavourable',
                        description: 'Conditions are currently limiting fruiting potential.'
                    }
                };

                this.isLoading = false;
                this.lastUpdate = null;

                this.init();
            }
            
            async init() {
                try {
                    this.setupMap();
                    this.setupUI();
                    this.showMessage('Map initialized. Click "Refresh Data" to load habitat analysis.', 'info');
                    this.updateStatus('Ready - Click Refresh Data to begin analysis');
                } catch (error) {
                    console.error('Initialization error:', error);
                    this.showMessage('Failed to initialize map. Please refresh the page.', 'error');
                }
            }
            
            setupMap() {
                // Initialize map
                this.map = L.map('map', {
                    center: [54.5, -3.0],
                    zoom: 6,
                    minZoom: 5,
                    maxZoom: 12,
                    maxBounds: this.ukBounds
                });

                this.map.createPane('suitabilityPane');
                const suitabilityPane = this.map.getPane('suitabilityPane');
                if (suitabilityPane) {
                    suitabilityPane.style.zIndex = 430;
                    suitabilityPane.style.mixBlendMode = 'normal';
                }

                // Add base layer
                const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors',
                    maxZoom: 18
                });
                osmLayer.addTo(this.map);
                
                // Initialize layer control
                this.layerControl = L.control.layers({}, {}, {
                    position: 'topright',
                    collapsed: false
                }).addTo(this.map);
                
                console.log('Map initialized successfully');
            }
            
            setupUI() {
                // Sidebar toggle
                document.getElementById('toggleSidebar').onclick = () => {
                    const sidebar = document.getElementById('sidebar');
                    sidebar.classList.toggle('collapsed');
                    document.getElementById('toggleSidebar').textContent = 
                        sidebar.classList.contains('collapsed') ? '→' : '←';
                    setTimeout(() => this.map.invalidateSize(), 300);
                };
                
                // Refresh button
                document.getElementById('refreshData').onclick = () => this.refreshData();
                
                // Weight sliders
                Object.keys(this.weights).forEach(key => {
                    const slider = document.getElementById(key + 'Weight');
                    if (slider) {
                        slider.oninput = (e) => {
                            this.weights[key] = parseFloat(e.target.value);
                            this.updateWeightDisplay(key, e.target.value);
                            this.debounceRecompute();
                        };
                    }
                });
                
                // Thresholds
                document.getElementById('minRain').oninput = (e) => {
                    this.rainThresholds.min = parseFloat(e.target.value);
                    this.debounceRecompute();
                };
                document.getElementById('maxRain').oninput = (e) => {
                    this.rainThresholds.max = parseFloat(e.target.value);
                    this.debounceRecompute();
                };
                
                // Weather source
                document.getElementById('weatherSource').onchange = (e) => {
                    document.getElementById('apiKeyControl').style.display = 
                        e.target.value === 'met-office' ? 'block' : 'none';
                };
                
                // Layer toggles
                ['suitability', 'landcover', 'rainfall', 'soil'].forEach(layer => {
                    const checkbox = document.getElementById('show' + layer.charAt(0).toUpperCase() + layer.slice(1));
                    if (checkbox) {
                        checkbox.onchange = (e) => this.toggleLayer(layer, e.target.checked);
                    }
                });
            }
            
            updateWeightDisplay(key, value) {
                const slider = document.getElementById(key + 'Weight');
                if (slider) {
                    const display = slider.parentNode.querySelector('.weight-value');
                    if (display) display.textContent = parseFloat(value).toFixed(2);
                }
            }
            
            debounceRecompute() {
                clearTimeout(this.recomputeTimeout);
                this.recomputeTimeout = setTimeout(() => this.recomputeSuitability(), 500);
            }
            
            async refreshData() {
                if (this.isLoading) return;
                
                this.setLoading(true);
                this.hideMessages();
                
                try {
                    this.updateStatus('Generating analysis grid...');
                    await this.generateGrid();
                    
                    this.updateStatus('Fetching weather data...');
                    await this.fetchWeatherData();
                    
                    this.updateStatus('Loading soil data...');
                    await this.fetchSoilData();
                    
                    this.updateStatus('Loading land cover data...');
                    await this.fetchLandCoverData();
                    
                    this.updateStatus('Computing habitat suitability...');
                    await this.recomputeSuitability();
                    
                    this.lastUpdate = new Date();
                    this.updateStatus(`Analysis complete - ${this.lastUpdate.toLocaleTimeString()} | ${this.gridCells.size} cells analyzed`);
                    this.showMessage('Habitat analysis complete! Explore the map to see suitability scores.', 'info');
                    
                } catch (error) {
                    console.error('Data refresh error:', error);
                    this.showMessage(`Error: ${error.message}`, 'error');
                    this.updateStatus('Error occurred during analysis');
                } finally {
                    this.setLoading(false);
                }
            }
            
            async generateGrid() {
                this.gridCells.clear();
                const [south, west] = this.ukBounds[0];
                const [north, east] = this.ukBounds[1];
                
                let cellCount = 0;
                for (let lat = south; lat < north; lat += this.gridSize) {
                    for (let lng = west; lng < east; lng += this.gridSize) {
                        const cellId = `cell_${Math.round(lat*100)}_${Math.round(lng*100)}`;
                        const bounds = [
                            [lat, lng],
                            [lat + this.gridSize, lng],
                            [lat + this.gridSize, lng + this.gridSize],
                            [lat, lng + this.gridSize],
                            [lat, lng]
                        ];
                        
                        this.gridCells.set(cellId, {
                            id: cellId,
                            lat: lat + this.gridSize/2,
                            lng: lng + this.gridSize/2,
                            bounds: bounds,
                            properties: {}
                        });
                        cellCount++;
                    }
                }
                console.log(`Generated ${cellCount} grid cells`);
            }
            
            async fetchWeatherData() {
                const source = document.getElementById('weatherSource').value;
                const cells = Array.from(this.gridCells.values());
                const batchSize = 20;
                
                this.weatherCache.clear();
                
                for (let i = 0; i < cells.length; i += batchSize) {
                    const batch = cells.slice(i, i + batchSize);
                    
                    if (source === 'open-meteo') {
                        await this.fetchOpenMeteoData(batch);
                    } else {
                        await this.fetchMetOfficeData(batch);
                    }
                    
                    this.updateStatus(`Weather data: ${Math.min(i + batchSize, cells.length)}/${cells.length} cells`);
                    await this.delay(200); // Rate limiting
                }
            }
            
            async fetchOpenMeteoData(cells) {
                try {
                    // Build API request for batch
                    const lats = cells.map(c => c.lat.toFixed(4)).join(',');
                    const lngs = cells.map(c => c.lng.toFixed(4)).join(',');
                    
                    const url = `https://api.open-meteo.com/v1/forecast?` +
                        `latitude=${lats}&longitude=${lngs}` +
                        `&hourly=precipitation,temperature_2m` +
                        `&past_days=3&forecast_days=0` +
                        `&timezone=Europe/London`;
                    
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Weather API error: ${response.status}`);
                    
                    const data = await response.json();
                    
                    // Process data for each cell
                    cells.forEach((cell, index) => {
                        const precipitation = Array.isArray(data.hourly?.precipitation) ? 
                            data.hourly.precipitation : data.hourly?.precipitation?.[index] || [];
                        const temperature = Array.isArray(data.hourly?.temperature_2m) ?
                            data.hourly.temperature_2m : data.hourly?.temperature_2m?.[index] || [];
                        
                        const last72h = precipitation.slice(-72);
                        const rainfall72h = last72h.reduce((sum, val) => sum + (val || 0), 0);
                        
                        const tempLast72 = temperature.slice(-72).filter(t => t != null);
                        const tempMax = tempLast72.length > 0 ? Math.max(...tempLast72) : 12;
                        const tempMin = tempLast72.length > 0 ? Math.min(...tempLast72) : 4;
                        
                        this.weatherCache.set(cell.id, {
                            rainfall_72h: rainfall72h,
                            temp_max: tempMax,
                            temp_min: tempMin,
                            source: 'open-meteo'
                        });
                    });
                    
                } catch (error) {
                    console.warn('OpenMeteo fetch failed:', error);
                    // Fallback to realistic synthetic data
                    cells.forEach(cell => {
                        this.weatherCache.set(cell.id, {
                            rainfall_72h: 5 + Math.random() * 25, // 5-30mm
                            temp_max: 8 + Math.random() * 12, // 8-20°C  
                            temp_min: Math.random() * 8, // 0-8°C
                            source: 'synthetic'
                        });
                    });
                }
            }
            
            async fetchMetOfficeData(cells) {
                const apiKey = document.getElementById('metOfficeKey').value;
                if (!apiKey) {
                    throw new Error('Met Office API key required');
                }
                
                // Met Office API implementation would go here
                // For now, use synthetic data
                cells.forEach(cell => {
                    this.weatherCache.set(cell.id, {
                        rainfall_72h: 8 + Math.random() * 20,
                        temp_max: 10 + Math.random() * 10,
                        temp_min: 2 + Math.random() * 6,
                        source: 'met-office'
                    });
                });
            }
            
            async fetchSoilData() {
                const source = document.getElementById('soilDataSource').value;
                this.soilCache.clear();
                
                // For real implementation, this would query SoilGrids or UKSO APIs
                // Using realistic synthetic data based on UK soil patterns
                this.gridCells.forEach((cell, cellId) => {
                    // Simulate realistic UK soil patterns
                    const isHighland = cell.lat > 56; // Scotland highlands
                    const isWest = cell.lng < -2; // Western regions
                    
                    let ph, drainage;
                    
                    if (isHighland) {
                        ph = 4.0 + Math.random() * 2.0; // Acidic highland soils
                        drainage = Math.random() > 0.3 ? 'well' : 'moderate';
                    } else if (isWest) {
                        ph = 4.5 + Math.random() * 2.5; // Slightly acidic western soils
                        drainage = Math.random() > 0.4 ? 'well' : 'poor';
                    } else {
                        ph = 5.5 + Math.random() * 2.0; // More neutral eastern soils
                        drainage = Math.random() > 0.5 ? 'moderate' : 'well';
                    }
                    
                    this.soilCache.set(cellId, {
                        ph: ph,
                        drainage: drainage,
                        source: source
                    });
                });
            }
            
            async fetchLandCoverData() {
                const source = document.getElementById('landcoverSource').value;
                this.landcoverCache.clear();
                
                // For real implementation, this would query ESA WorldCover or CORINE APIs
                // Using realistic land cover patterns for UK
                this.gridCells.forEach((cell, cellId) => {
                    const isUrban = this.isNearMajorCity(cell.lat, cell.lng);
                    const isHighland = cell.lat > 55.5;
                    const isCoastal = this.isCoastal(cell.lat, cell.lng);
                    
                    let landcover, score;
                    
                    if (isUrban) {
                        landcover = 'urban';
                        score = 0.1;
                    } else if (isHighland) {
                        const rand = Math.random();
                        if (rand < 0.4) {
                            landcover = 'acid_grassland';
                            score = 1.0;
                        } else if (rand < 0.7) {
                            landcover = 'heath';
                            score = 1.0;
                        } else {
                            landcover = 'rough_pasture';
                            score = 1.0;
                        }
                    } else if (isCoastal) {
                        const rand = Math.random();
                        if (rand < 0.5) {
                            landcover = 'improved_grassland';
                            score = 0.5;
                        } else {
                            landcover = 'rough_pasture';
                            score = 1.0;
                        }
                    } else {
                        const rand = Math.random();
                        if (rand < 0.3) {
                            landcover = 'arable';
                            score = 0.2;
                        } else if (rand < 0.6) {
                            landcover = 'improved_grassland';
                            score = 0.5;
                        } else if (rand < 0.8) {
                            landcover = 'mixed_grass_shrub';
                            score = 0.7;
                        } else {
                            landcover = 'rough_pasture';
                            score = 1.0;
                        }
                    }
                    
                    this.landcoverCache.set(cellId, {
                        landcover: landcover,
                        landcover_score: score,
                        source: source
                    });
                });
            }
            
            isNearMajorCity(lat, lng) {
                const cities = [
                    [51.5074, -0.1278], // London
                    [53.4808, -2.2426], // Manchester
                    [52.4862, -1.8904], // Birmingham
                    [55.8642, -4.2518], // Glasgow
                    [55.9533, -3.1883], // Edinburgh
                    [53.3811, -1.4701], // Sheffield
                    [53.7632, -0.3282], // Hull
                    [54.9783, -1.6178]  // Newcastle
                ];
                
                return cities.some(([cityLat, cityLng]) => {
                    const distance = Math.sqrt(Math.pow(lat - cityLat, 2) + Math.pow(lng - cityLng, 2));
                    return distance < 0.2; // Within ~20km
                });
            }
            
            isCoastal(lat, lng) {
                // Simplified coastal detection for UK
                return (lng < -4 || lng > 1.5 || lat < 50.5 || 
                       (lat > 57.5 && lng < -2) || // Scottish highlands
                       (lat > 54 && lng < -3));    // Welsh coast
            }
            
            async recomputeSuitability() {
                if (this.gridCells.size === 0) {
                    throw new Error('No grid cells available. Please refresh data first.');
                }
                
                const results = [];
                let processedCount = 0;
                
                for (const [cellId, cell] of this.gridCells) {
                    const weather = this.weatherCache.get(cellId) || this.getDefaultWeather();
                    const soil = this.soilCache.get(cellId) || this.getDefaultSoil();
                    const landcover = this.landcoverCache.get(cellId) || this.getDefaultLandcover();
                    
                    const suitability = this.computeCellSuitability(weather, soil, landcover);
                    
                    results.push({
                        cellId,
                        cell,
                        weather,
                        soil,
                        landcover,
                        suitability
                    });
                    
                    processedCount++;
                    if (processedCount % 100 === 0) {
                        this.updateStatus(`Computing: ${processedCount}/${this.gridCells.size} cells`);
                        await this.delay(1); // Allow UI updates
                    }
                }
                
                await this.renderSuitabilityLayer(results);
                this.updateStatistics(results);
            }
            
            getDefaultWeather() {
                return {
                    rainfall_72h: 15,
                    temp_max: 12,
                    temp_min: 4,
                    source: 'default'
                };
            }
            
            getDefaultSoil() {
                return {
                    ph: 6.0,
                    drainage: 'moderate',
                    source: 'default'
                };
            }
            
            getDefaultLandcover() {
                return {
                    landcover: 'improved_grassland',
                    landcover_score: 0.5,
                    source: 'default'
                };
            }
            
            computeCellSuitability(weather, soil, landcover) {
                // Land cover score
                const landcoverScore = landcover.landcover_score;
                
                // Soil pH score (Gaussian curve centered at 5.5)
                const phScore = Math.exp(-0.5 * Math.pow((soil.ph - 5.5) / 1.0, 2));
                
                // Drainage score
                const drainageScores = {
                    'well': 1.0,
                    'moderate': 0.8,
                    'imperfect': 0.5,
                    'poor': 0.2,
                    'very_poor': 0.0
                };
                const drainScore = drainageScores[soil.drainage] || 0.5;
                
                // Grazing score (proxy from land cover)
                const grazeScores = {
                    'rough_pasture': 0.9,
                    'acid_grassland': 0.9,
                    'heath': 0.8,
                    'mixed_grass_shrub': 0.7,
                    'improved_grassland': 0.5,
                    'arable': 0.2,
                    'urban': 0.1
                };
                const grazeScore = grazeScores[landcover.landcover] || 0.5;
                
                // Terrain score (simplified - using location as proxy)
                const terrainScore = 0.8; // Placeholder
                
                // Climate score
                const tempMax = weather.temp_max;
                const tempMin = weather.temp_min;
                
                let tmaxScore = 0;
                if (tempMax >= 8 && tempMax <= 18) {
                    tmaxScore = tempMax === 12 ? 1.0 : 0.8;
                } else if (tempMax >= 5 && tempMax <= 22) {
                    tmaxScore = 0.3;
                }
                
                let tminScore = 0;
                if (tempMin >= 0 && tempMin <= 10) {
                    tminScore = tempMin === 6 ? 1.0 : 0.8;
                } else if (tempMin >= -3 && tempMin <= 14) {
                    tminScore = 0.3;
                }
                
                const climateScore = (tmaxScore + tminScore) / 2;
                
                // Base suitability
                const base = 
                    this.weights.landcover * landcoverScore +
                    this.weights.ph * phScore +
                    this.weights.drainage * drainScore +
                    this.weights.grazing * grazeScore +
                    this.weights.terrain * terrainScore +
                    this.weights.climate * climateScore;
                
                // Rainfall adjustments
                const rainfall72h = weather.rainfall_72h;
                let rainBonus = 0;
                let waterlogged = false;
                
                if (rainfall72h >= this.rainThresholds.min && rainfall72h <= this.rainThresholds.max) {
                    rainBonus = 0.05;
                } else if (rainfall72h > this.rainThresholds.max) {
                    waterlogged = drainScore < 0.8;
                }
                
                // Final score
                let final = Math.max(0, Math.min(1, base + rainBonus));
                if (waterlogged) final = Math.min(final, 0.49);

                // Category + colour styling
                let category = 'poor';
                if (final >= 0.70 && rainfall72h >= this.rainThresholds.min && rainfall72h <= this.rainThresholds.max) {
                    category = 'ideal';
                } else if (final >= 0.50 && rainfall72h < this.rainThresholds.min) {
                    category = 'caution';
                }

                const style = this.categoryStyles[category] || this.categoryStyles.poor;

                return {
                    base,
                    final,
                    color: style.fill,
                    borderColor: style.border,
                    category,
                    categoryLabel: style.label,
                    categoryDescription: style.description,
                    dashArray: style.dashArray || null,
                    components: {
                        landcover: landcoverScore,
                        ph: phScore,
                        drainage: drainScore,
                        grazing: grazeScore,
                        terrain: terrainScore,
                        climate: climateScore
                    },
                    waterlogged,
                    rainBonus
                };
            }
            
            async renderSuitabilityLayer(results) {
                // Remove existing layer
                if (this.gridLayer) {
                    this.map.removeLayer(this.gridLayer);
                    this.layerControl.removeLayer(this.gridLayer);
                }
                
                const features = results.map(result => ({
                    type: 'Feature',
                    geometry: {
                        type: 'Polygon',
                        coordinates: [result.cell.bounds]
                    },
                    properties: {
                        cellId: result.cellId,
                        suitability: result.suitability,
                        weather: result.weather,
                        soil: result.soil,
                        landcover: result.landcover
                    }
                }));
                
                const geojsonData = {
                    type: 'FeatureCollection',
                    features
                };
                
                this.gridLayer = L.geoJSON(geojsonData, {
                    pane: 'suitabilityPane',
                    style: (feature) => {
                        const suitability = feature.properties.suitability;
                        const category = suitability.category;
                        const styleDef = this.categoryStyles[category] || this.categoryStyles.poor;
                        const fillOpacity = category === 'ideal' ? 0.78 : category === 'caution' ? 0.64 : 0.58;
                        const weight = category === 'poor' ? 1.1 : 0.9;

                        return {
                            fillColor: suitability.color,
                            weight,
                            opacity: 0.9,
                            color: suitability.borderColor || styleDef.border,
                            fillOpacity,
                            dashArray: suitability.dashArray || styleDef.dashArray || null
                        };
                    },
                    onEachFeature: (feature, layer) => {
                        this.bindCellPopup(layer, feature.properties);

                        layer.on('mouseover', () => {
                            const category = feature.properties.suitability.category;
                            const styleDef = this.categoryStyles[category] || this.categoryStyles.poor;
                            layer.setStyle({
                                weight: 2,
                                opacity: 1,
                                color: styleDef.border,
                                fillOpacity: category === 'ideal' ? 0.9 : category === 'caution' ? 0.78 : 0.7,
                                dashArray: ''
                            });
                            if (layer.bringToFront) {
                                layer.bringToFront();
                            }
                        });

                        layer.on('mouseout', () => {
                            this.gridLayer.resetStyle(layer);
                        });
                    }
                });
                
                // Add to map if enabled
                if (document.getElementById('showSuitability').checked) {
                    this.gridLayer.addTo(this.map);
                }
                
                // Add to layer control
                this.layerControl.addOverlay(this.gridLayer, 'Habitat Suitability');
            }
            
            bindCellPopup(layer, properties) {
                const { suitability, weather, soil, landcover } = properties;

                const scorePercent = Math.round(suitability.final * 100);
                const clampedPercent = Math.min(100, Math.max(0, scorePercent));
                const category = suitability.category;
                const categoryLabel = suitability.categoryLabel || (this.categoryStyles[category]?.label ?? 'Suitability');
                const categoryDescription = suitability.categoryDescription || (this.categoryStyles[category]?.description ?? '');

                const rainfallAmount = typeof weather.rainfall_72h === 'number' ? weather.rainfall_72h : 0;
                const tempMax = typeof weather.temp_max === 'number' ? weather.temp_max : 0;
                const tempMin = typeof weather.temp_min === 'number' ? weather.temp_min : 0;
                const rainfallRange = `${this.rainThresholds.min}-${this.rainThresholds.max}`;

                let rainfallMessage = 'Within preferred window';
                if (suitability.waterlogged) {
                    rainfallMessage = 'Too wet for current drainage class';
                } else if (rainfallAmount < this.rainThresholds.min) {
                    rainfallMessage = 'Below trigger threshold';
                } else if (rainfallAmount > this.rainThresholds.max) {
                    rainfallMessage = 'Above preferred window';
                }

                const landcoverLabel = landcover.landcover || 'unknown cover';
                const soilDrainage = soil.drainage || 'unknown';
                const soilPh = typeof soil.ph === 'number' ? soil.ph : 0;

                const popupContent = `
                    <div class="popup-content">
                        <div class="popup-header">
                            <strong>Habitat suitability</strong>
                            <span class="popup-badge ${category}">
                                <span class="badge-dot"></span>${categoryLabel}
                            </span>
                        </div>
                        <div class="popup-score">
                            <div class="score-number">${clampedPercent}%</div>
                            <div class="score-bar">
                                <div class="score-fill ${category}" style="width: ${clampedPercent}%;"></div>
                            </div>
                            <div class="score-caption">${categoryDescription}</div>
                        </div>
                        ${suitability.waterlogged ? '<div class="popup-warning">⚠ Waterlogged conditions detected – drainage is restricting the rainfall bonus.</div>' : ''}
                        <div class="popup-section">
                            <strong>Component scores</strong>
                            <small>
                                Land cover: ${suitability.components.landcover.toFixed(2)} (${landcoverLabel})<br>
                                Soil pH: ${suitability.components.ph.toFixed(2)} (pH ${soilPh.toFixed(1)})<br>
                                Drainage: ${suitability.components.drainage.toFixed(2)} (${soilDrainage})<br>
                                Grazing proxy: ${suitability.components.grazing.toFixed(2)}<br>
                                Terrain: ${suitability.components.terrain.toFixed(2)}<br>
                                Climate: ${suitability.components.climate.toFixed(2)}
                            </small>
                        </div>
                        <div class="popup-section">
                            <strong>Recent weather (72&nbsp;h)</strong>
                            <small>
                                Rainfall: ${rainfallAmount.toFixed(1)} mm (${rainfallMessage})<br>
                                Ideal window: ${rainfallRange} mm<br>
                                Max temp: ${tempMax.toFixed(1)}°C | Min temp: ${tempMin.toFixed(1)}°C
                            </small>
                        </div>
                        <div class="popup-section">
                            <strong>Data sources</strong>
                            <small>${weather.source} weather · ${soil.source} soil · ${landcover.source} land cover</small>
                        </div>
                    </div>
                `;
                
                layer.bindPopup(popupContent, {
                    maxWidth: 300,
                    className: 'custom-popup'
                });
            }
            
            updateStatistics(results) {
                if (!Array.isArray(results) || results.length === 0) {
                    this.updateStatus('Awaiting analysis results');
                    this.updateSummaryChips({ ideal: 0, caution: 0, poor: 0 }, 0);
                    return;
                }

                const summary = { ideal: 0, caution: 0, poor: 0 };
                for (const result of results) {
                    const category = result.suitability?.category;
                    if (summary.hasOwnProperty(category)) {
                        summary[category] += 1;
                    } else {
                        summary.poor += 1;
                    }
                }

                const avgScore = results.reduce((sum, r) => sum + (r.suitability?.final || 0), 0) / results.length;
                const timestamp = this.lastUpdate instanceof Date ? this.lastUpdate : new Date();
                if (!(this.lastUpdate instanceof Date)) {
                    this.lastUpdate = timestamp;
                }
                this.updateStatus(`Analysis complete · ${results.length} cells · ${timestamp.toLocaleTimeString()}`);
                this.updateSummaryChips(summary, avgScore);
            }

            updateSummaryChips(summary, avgScore) {
                const avgElement = document.getElementById('avgScoreChip');
                if (avgElement) {
                    avgElement.textContent = avgScore.toFixed(2);
                }

                const mapping = [
                    { key: 'ideal', elementId: 'idealCount' },
                    { key: 'caution', elementId: 'cautionCount' },
                    { key: 'poor', elementId: 'poorCount' }
                ];

                mapping.forEach(({ key, elementId }) => {
                    const element = document.getElementById(elementId);
                    if (element) {
                        element.textContent = summary?.[key] ? summary[key] : 0;
                    }
                });
            }
            
            toggleLayer(layerType, show) {
                switch (layerType) {
                    case 'suitability':
                        if (this.gridLayer) {
                            if (show && !this.map.hasLayer(this.gridLayer)) {
                                this.map.addLayer(this.gridLayer);
                            } else if (!show && this.map.hasLayer(this.gridLayer)) {
                                this.map.removeLayer(this.gridLayer);
                            }
                        }
                        break;
                    case 'landcover':
                    case 'rainfall': 
                    case 'soil':
                        // Placeholder for additional overlay layers
                        console.log(`${layerType} layer toggle:`, show);
                        break;
                }
            }
            
            setLoading(loading) {
                this.isLoading = loading;
                const spinner = document.getElementById('loadingSpinner');
                const button = document.getElementById('refreshData');
                
                if (loading) {
                    spinner.classList.remove('hidden');
                    button.disabled = true;
                    button.style.opacity = '0.5';
                } else {
                    spinner.classList.add('hidden');
                    button.disabled = false;
                    button.style.opacity = '1';
                }
            }
            
            showMessage(message, type) {
                this.hideMessages();
                const elementId = type === 'error' ? 'errorMessage' : 'infoMessage';
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = message;
                    element.classList.remove('hidden');
                }
            }
            
            hideMessages() {
                document.getElementById('errorMessage').classList.add('hidden');
                document.getElementById('infoMessage').classList.add('hidden');
            }
            
            updateStatus(message) {
                const statusElement = document.getElementById('statusText');
                if (statusElement) {
                    statusElement.textContent = message;
                }
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }
        
        // Initialize application
        document.addEventListener('DOMContentLoaded', () => {
            try {
                new LibertyCapsHabitatMap();
            } catch (error) {
                console.error('Failed to initialize application:', error);
                document.getElementById('statusText').textContent = 'Failed to initialize - please refresh page';
            }
        });
    </script>
</body>
</html>
