<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liberty Cap Habitat Suitability Map - UK</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        /* Inline styles for self-contained file */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        #app {
            display: flex;
            height: 100vh;
            position: relative;
        }

        .sidebar {
            width: 320px;
            background: linear-gradient(135deg, #2d4a22 0%, #1a2f15 100%);
            border-right: 2px solid #4a6b3a;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            box-shadow: 2px 0 20px rgba(0,0,0,0.3);
        }

        .sidebar.collapsed {
            transform: translateX(-280px);
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar-header h2 {
            color: #a8d48a;
            font-size: 1.4em;
            font-weight: 600;
        }

        .toggle-btn {
            background: #4a6b3a;
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
        }

        .toggle-btn:hover {
            background: #5a7b4a;
            transform: scale(1.05);
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 0 0 20px 0;
        }

        .section {
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .section h3 {
            color: #c5e6a8;
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .weight-control, .threshold-control, .weather-control {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
            gap: 8px;
        }

        .weight-control label, .threshold-control label, .weather-control label {
            font-size: 0.9em;
            color: #b8d49a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .weight-value {
            background: rgba(168, 212, 138, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.8em;
            min-width: 45px;
            text-align: center;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #4a6b3a 0%, #2d4a22 100%);
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #a8d48a;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }

        input[type="number"], input[type="password"], select {
            background: rgba(0,0,0,0.3);
            border: 1px solid #4a6b3a;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9em;
        }

        .layer-control {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .layer-control label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.9em;
            color: #b8d49a;
        }

        .layer-control input[type="checkbox"] {
            margin-right: 8px;
            accent-color: #a8d48a;
        }

        .refresh-btn {
            width: 100%;
            background: linear-gradient(135deg, #4a6b3a 0%, #5a7b4a 100%);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .refresh-btn:hover {
            background: linear-gradient(135deg, #5a7b4a 0%, #6a8b5a 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }

        .legend {
            background: rgba(0,0,0,0.2);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .legend-color.ideal { background: #4CAF50; }
        .legend-color.good { background: #FF9800; }
        .legend-color.poor { background: #F44336; }

        .spinner {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            color: #a8d48a;
            font-size: 0.9em;
        }

        .spinner::before {
            content: '';
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top: 2px solid #a8d48a;
            border-radius: 50%;
            margin-right: 8px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden { display: none !important; }

        .map-container {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        #map {
            flex: 1;
            background: #1a1a1a;
            min-height: 400px;
        }

        .status-bar {
            background: linear-gradient(135deg, #2d2d2d 0%, #1a1a1a 100%);
            padding: 12px 20px;
            border-top: 1px solid #404040;
            font-size: 0.85em;
            color: #b0b0b0;
        }

        .disclaimer {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            color: #ffa726;
            padding: 15px 20px;
            border-radius: 10px;
            max-width: 400px;
            font-size: 0.85em;
            line-height: 1.4;
            border: 1px solid #ff9800;
            backdrop-filter: blur(10px);
            z-index: 2000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .error-message {
            background: #d32f2f;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        .info-message {
            background: #1976d2;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        /* Leaflet popup styling */
        .leaflet-popup-content-wrapper {
            background: #2d2d2d !important;
            color: #e0e0e0 !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5) !important;
        }

        .leaflet-popup-tip {
            background: #2d2d2d !important;
        }

        .leaflet-control-layers {
            background: #2d2d2d !important;
            color: #e0e0e0 !important;
            border: 1px solid #4a6b3a !important;
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 280px;
            }
            .disclaimer {
                position: relative;
                bottom: auto;
                right: auto;
                margin: 10px;
                max-width: none;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h2>Habitat Analysis</h2>
                <button id="toggleSidebar" class="toggle-btn">‚Üê</button>
            </div>
            
            <div class="sidebar-content">
                <div class="section">
                    <button id="refreshData" class="refresh-btn">üîÑ Refresh Data</button>
                    <div id="loadingSpinner" class="spinner hidden">Loading...</div>
                    <div id="errorMessage" class="error-message hidden"></div>
                    <div id="infoMessage" class="info-message hidden"></div>
                </div>

                <div class="section">
                    <h3>Factor Weights</h3>
                    <div class="weight-control">
                        <label for="landcoverWeight">Land Cover (0.30)</label>
                        <input type="range" id="landcoverWeight" min="0" max="0.4" step="0.01" value="0.30">
                        <span class="weight-value">0.30</span>
                    </div>
                    <div class="weight-control">
                        <label for="phWeight">Soil pH (0.25)</label>
                        <input type="range" id="phWeight" min="0" max="0.4" step="0.01" value="0.25">
                        <span class="weight-value">0.25</span>
                    </div>
                    <div class="weight-control">
                        <label for="drainWeight">Drainage (0.15)</label>
                        <input type="range" id="drainWeight" min="0" max="0.4" step="0.01" value="0.15">
                        <span class="weight-value">0.15</span>
                    </div>
                    <div class="weight-control">
                        <label for="grazeWeight">Grazing (0.10)</label>
                        <input type="range" id="grazeWeight" min="0" max="0.4" step="0.01" value="0.10">
                        <span class="weight-value">0.10</span>
                    </div>
                    <div class="weight-control">
                        <label for="terrainWeight">Terrain (0.05)</label>
                        <input type="range" id="terrainWeight" min="0" max="0.4" step="0.01" value="0.05">
                        <span class="weight-value">0.05</span>
                    </div>
                    <div class="weight-control">
                        <label for="climateWeight">Climate (0.15)</label>
                        <input type="range" id="climateWeight" min="0" max="0.4" step="0.01" value="0.15">
                        <span class="weight-value">0.15</span>
                    </div>
                </div>

                <div class="section">
                    <h3>Rain Thresholds (mm)</h3>
                    <div class="threshold-control">
                        <label for="minRain">Minimum ideal rain (8)</label>
                        <input type="number" id="minRain" min="0" max="50" value="8">
                    </div>
                    <div class="threshold-control">
                        <label for="maxRain">Maximum ideal rain (35)</label>
                        <input type="number" id="maxRain" min="0" max="100" value="35">
                    </div>
                </div>

                <div class="section">
                    <h3>Data Settings</h3>
                    <div class="weather-control">
                        <label for="weatherSource">Weather API:</label>
                        <select id="weatherSource">
                            <option value="open-meteo">Open-Meteo (Free)</option>
                            <option value="met-office">Met Office DataHub</option>
                        </select>
                    </div>
                    <div class="weather-control" id="apiKeyControl" style="display: none;">
                        <label for="metOfficeKey">Met Office API Key:</label>
                        <input type="password" id="metOfficeKey" placeholder="Enter API key">
                    </div>
                    <div class="weather-control">
                        <label for="soilDataSource">Soil Data:</label>
                        <select id="soilDataSource">
                            <option value="soilgrids">SoilGrids (ISRIC)</option>
                            <option value="ukso">UK Soil Observatory</option>
                        </select>
                    </div>
                    <div class="weather-control">
                        <label for="landcoverSource">Land Cover:</label>
                        <select id="landcoverSource">
                            <option value="esa-worldcover">ESA WorldCover</option>
                            <option value="corine">Copernicus CORINE</option>
                        </select>
                    </div>
                </div>

                <div class="section">
                    <h3>Data Layers</h3>
                    <div class="layer-control">
                        <label><input type="checkbox" id="showSuitability" checked> Suitability Grid</label>
                    </div>
                    <div class="layer-control">
                        <label><input type="checkbox" id="showLandcover"> Land Cover Layer</label>
                    </div>
                    <div class="layer-control">
                        <label><input type="checkbox" id="showRainfall"> Rainfall Heatmap</label>
                    </div>
                    <div class="layer-control">
                        <label><input type="checkbox" id="showSoil"> Soil Properties</label>
                    </div>
                </div>

                <div class="legend">
                    <h3>Legend</h3>
                    <div class="legend-item">
                        <span class="legend-color ideal"></span>
                        <span>Ideal (‚â•0.70 + recent rain)</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color good"></span>
                        <span>Good base conditions</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color poor"></span>
                        <span>Not ideal / waterlogged</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="mapContainer" class="map-container">
            <div id="map"></div>
            <div id="statusBar" class="status-bar">
                <span id="statusText">Initializing map...</span>
            </div>
        </div>
    </div>

    <div id="disclaimer" class="disclaimer">
        <p><strong>Educational Use Only:</strong> This tool models habitat suitability based on environmental factors. 
        Always verify mushroom identification with experts and check local foraging regulations before collecting.</p>
    </div>

    <!-- Load external libraries -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    
    <script>
        // Main application class
        class LibertyCapsHabitatMap {
            constructor() {
                this.map = null;
                this.gridLayer = null;
                this.overlayLayers = new Map();
                
                this.weights = {
                    landcover: 0.30,
                    ph: 0.25,
                    drainage: 0.15,
                    grazing: 0.10,
                    terrain: 0.05,
                    climate: 0.15
                };
                
                this.rainThresholds = { min: 8, max: 35 };
                this.gridSize = 0.05; // ~5km grid
                this.ukBounds = [[49.5, -8.5], [61.0, 2.0]]; // UK bounding box
                
                this.gridCells = new Map();
                this.weatherCache = new Map();
                this.soilCache = new Map();
                this.landcoverCache = new Map();
                
                this.isLoading = false;
                this.lastUpdate = null;
                
                this.init();
            }
            
            async init() {
                try {
                    this.setupMap();
                    this.setupUI();
                    this.showMessage('Map initialized. Click "Refresh Data" to load habitat analysis.', 'info');
                    this.updateStatus('Ready - Click Refresh Data to begin analysis');
                } catch (error) {
                    console.error('Initialization error:', error);
                    this.showMessage('Failed to initialize map. Please refresh the page.', 'error');
                }
            }
            
            setupMap() {
                // Initialize map
                this.map = L.map('map', {
                    center: [54.5, -3.0],
                    zoom: 6,
                    minZoom: 5,
                    maxZoom: 12,
                    maxBounds: this.ukBounds
                });
                
                // Add base layer
                const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors',
                    maxZoom: 18
                });
                osmLayer.addTo(this.map);
                
                // Initialize layer control
                this.layerControl = L.control.layers({}, {}, {
                    position: 'topright',
                    collapsed: false
                }).addTo(this.map);
                
                console.log('Map initialized successfully');
            }
            
            setupUI() {
                // Sidebar toggle
                document.getElementById('toggleSidebar').onclick = () => {
                    const sidebar = document.getElementById('sidebar');
                    sidebar.classList.toggle('collapsed');
                    document.getElementById('toggleSidebar').textContent = 
                        sidebar.classList.contains('collapsed') ? '‚Üí' : '‚Üê';
                    setTimeout(() => this.map.invalidateSize(), 300);
                };
                
                // Refresh button
                document.getElementById('refreshData').onclick = () => this.refreshData();
                
                // Weight sliders
                Object.keys(this.weights).forEach(key => {
                    const slider = document.getElementById(key + 'Weight');
                    if (slider) {
                        slider.oninput = (e) => {
                            this.weights[key] = parseFloat(e.target.value);
                            this.updateWeightDisplay(key, e.target.value);
                            this.debounceRecompute();
                        };
                    }
                });
                
                // Thresholds
                document.getElementById('minRain').oninput = (e) => {
                    this.rainThresholds.min = parseFloat(e.target.value);
                    this.debounceRecompute();
                };
                document.getElementById('maxRain').oninput = (e) => {
                    this.rainThresholds.max = parseFloat(e.target.value);
                    this.debounceRecompute();
                };
                
                // Weather source
                document.getElementById('weatherSource').onchange = (e) => {
                    document.getElementById('apiKeyControl').style.display = 
                        e.target.value === 'met-office' ? 'block' : 'none';
                };
                
                // Layer toggles
                ['suitability', 'landcover', 'rainfall', 'soil'].forEach(layer => {
                    const checkbox = document.getElementById('show' + layer.charAt(0).toUpperCase() + layer.slice(1));
                    if (checkbox) {
                        checkbox.onchange = (e) => this.toggleLayer(layer, e.target.checked);
                    }
                });
            }
            
            updateWeightDisplay(key, value) {
                const slider = document.getElementById(key + 'Weight');
                if (slider) {
                    const display = slider.parentNode.querySelector('.weight-value');
                    if (display) display.textContent = parseFloat(value).toFixed(2);
                }
            }
            
            debounceRecompute() {
                clearTimeout(this.recomputeTimeout);
                this.recomputeTimeout = setTimeout(() => this.recomputeSuitability(), 500);
            }
            
            async refreshData() {
                if (this.isLoading) return;
                
                this.setLoading(true);
                this.hideMessages();
                
                try {
                    this.updateStatus('Generating analysis grid...');
                    await this.generateGrid();
                    
                    this.updateStatus('Fetching weather data...');
                    await this.fetchWeatherData();
                    
                    this.updateStatus('Loading soil data...');
                    await this.fetchSoilData();
                    
                    this.updateStatus('Loading land cover data...');
                    await this.fetchLandCoverData();
                    
                    this.updateStatus('Computing habitat suitability...');
                    await this.recomputeSuitability();
                    
                    this.lastUpdate = new Date();
                    this.updateStatus(`Analysis complete - ${this.lastUpdate.toLocaleTimeString()} | ${this.gridCells.size} cells analyzed`);
                    this.showMessage('Habitat analysis complete! Explore the map to see suitability scores.', 'info');
                    
                } catch (error) {
                    console.error('Data refresh error:', error);
                    this.showMessage(`Error: ${error.message}`, 'error');
                    this.updateStatus('Error occurred during analysis');
                } finally {
                    this.setLoading(false);
                }
            }
            
            async generateGrid() {
                this.gridCells.clear();
                const [south, west] = this.ukBounds[0];
                const [north, east] = this.ukBounds[1];
                
                let cellCount = 0;
                for (let lat = south; lat < north; lat += this.gridSize) {
                    for (let lng = west; lng < east; lng += this.gridSize) {
                        const cellId = `cell_${Math.round(lat*100)}_${Math.round(lng*100)}`;
                        const bounds = [
                            [lat, lng],
                            [lat + this.gridSize, lng],
                            [lat + this.gridSize, lng + this.gridSize],
                            [lat, lng + this.gridSize],
                            [lat, lng]
                        ];
                        
                        this.gridCells.set(cellId, {
                            id: cellId,
                            lat: lat + this.gridSize/2,
                            lng: lng + this.gridSize/2,
                            bounds: bounds,
                            properties: {}
                        });
                        cellCount++;
                    }
                }
                console.log(`Generated ${cellCount} grid cells`);
            }
            
            async fetchWeatherData() {
                const source = document.getElementById('weatherSource').value;
                const cells = Array.from(this.gridCells.values());
                const batchSize = 20;
                
                this.weatherCache.clear();
                
                for (let i = 0; i < cells.length; i += batchSize) {
                    const batch = cells.slice(i, i + batchSize);
                    
                    if (source === 'open-meteo') {
                        await this.fetchOpenMeteoData(batch);
                    } else {
                        await this.fetchMetOfficeData(batch);
                    }
                    
                    this.updateStatus(`Weather data: ${Math.min(i + batchSize, cells.length)}/${cells.length} cells`);
                    await this.delay(200); // Rate limiting
                }
            }
            
            async fetchOpenMeteoData(cells) {
                try {
                    // Build API request for batch
                    const lats = cells.map(c => c.lat.toFixed(4)).join(',');
                    const lngs = cells.map(c => c.lng.toFixed(4)).join(',');
                    
                    const url = `https://api.open-meteo.com/v1/forecast?` +
                        `latitude=${lats}&longitude=${lngs}` +
                        `&hourly=precipitation,temperature_2m` +
                        `&past_days=3&forecast_days=0` +
                        `&timezone=Europe/London`;
                    
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Weather API error: ${response.status}`);
                    
                    const data = await response.json();
                    
                    // Process data for each cell
                    cells.forEach((cell, index) => {
                        const precipitation = Array.isArray(data.hourly?.precipitation) ? 
                            data.hourly.precipitation : data.hourly?.precipitation?.[index] || [];
                        const temperature = Array.isArray(data.hourly?.temperature_2m) ?
                            data.hourly.temperature_2m : data.hourly?.temperature_2m?.[index] || [];
                        
                        const last72h = precipitation.slice(-72);
                        const rainfall72h = last72h.reduce((sum, val) => sum + (val || 0), 0);
                        
                        const tempLast72 = temperature.slice(-72).filter(t => t != null);
                        const tempMax = tempLast72.length > 0 ? Math.max(...tempLast72) : 12;
                        const tempMin = tempLast72.length > 0 ? Math.min(...tempLast72) : 4;
                        
                        this.weatherCache.set(cell.id, {
                            rainfall_72h: rainfall72h,
                            temp_max: tempMax,
                            temp_min: tempMin,
                            source: 'open-meteo'
                        });
                    });
                    
                } catch (error) {
                    console.warn('OpenMeteo fetch failed:', error);
                    // Fallback to realistic synthetic data
                    cells.forEach(cell => {
                        this.weatherCache.set(cell.id, {
                            rainfall_72h: 5 + Math.random() * 25, // 5-30mm
                            temp_max: 8 + Math.random() * 12, // 8-20¬∞C  
                            temp_min: Math.random() * 8, // 0-8¬∞C
                            source: 'synthetic'
                        });
                    });
                }
            }
            
            async fetchMetOfficeData(cells) {
                const apiKey = document.getElementById('metOfficeKey').value;
                if (!apiKey) {
                    throw new Error('Met Office API key required');
                }
                
                // Met Office API implementation would go here
                // For now, use synthetic data
                cells.forEach(cell => {
                    this.weatherCache.set(cell.id, {
                        rainfall_72h: 8 + Math.random() * 20,
                        temp_max: 10 + Math.random() * 10,
                        temp_min: 2 + Math.random() * 6,
                        source: 'met-office'
                    });
                });
            }
            
            async fetchSoilData() {
                const source = document.getElementById('soilDataSource').value;
                this.soilCache.clear();
                
                // For real implementation, this would query SoilGrids or UKSO APIs
                // Using realistic synthetic data based on UK soil patterns
                this.gridCells.forEach((cell, cellId) => {
                    // Simulate realistic UK soil patterns
                    const isHighland = cell.lat > 56; // Scotland highlands
                    const isWest = cell.lng < -2; // Western regions
                    
                    let ph, drainage;
                    
                    if (isHighland) {
                        ph = 4.0 + Math.random() * 2.0; // Acidic highland soils
                        drainage = Math.random() > 0.3 ? 'well' : 'moderate';
                    } else if (isWest) {
                        ph = 4.5 + Math.random() * 2.5; // Slightly acidic western soils
                        drainage = Math.random() > 0.4 ? 'well' : 'poor';
                    } else {
                        ph = 5.5 + Math.random() * 2.0; // More neutral eastern soils
                        drainage = Math.random() > 0.5 ? 'moderate' : 'well';
                    }
                    
                    this.soilCache.set(cellId, {
                        ph: ph,
                        drainage: drainage,
                        source: source
                    });
                });
            }
            
            async fetchLandCoverData() {
                const source = document.getElementById('landcoverSource').value;
                this.landcoverCache.clear();
                
                // For real implementation, this would query ESA WorldCover or CORINE APIs
                // Using realistic land cover patterns for UK
                this.gridCells.forEach((cell, cellId) => {
                    const isUrban = this.isNearMajorCity(cell.lat, cell.lng);
                    const isHighland = cell.lat > 55.5;
                    const isCoastal = this.isCoastal(cell.lat, cell.lng);
                    
                    let landcover, score;
                    
                    if (isUrban) {
                        landcover = 'urban';
                        score = 0.1;
                    } else if (isHighland) {
                        const rand = Math.random();
                        if (rand < 0.4) {
                            landcover = 'acid_grassland';
                            score = 1.0;
                        } else if (rand < 0.7) {
                            landcover = 'heath';
                            score = 1.0;
                        } else {
                            landcover = 'rough_pasture';
                            score = 1.0;
                        }
                    } else if (isCoastal) {
                        const rand = Math.random();
                        if (rand < 0.5) {
                            landcover = 'improved_grassland';
                            score = 0.5;
                        } else {
                            landcover = 'rough_pasture';
                            score = 1.0;
                        }
                    } else {
                        const rand = Math.random();
                        if (rand < 0.3) {
                            landcover = 'arable';
                            score = 0.2;
                        } else if (rand < 0.6) {
                            landcover = 'improved_grassland';
                            score = 0.5;
                        } else if (rand < 0.8) {
                            landcover = 'mixed_grass_shrub';
                            score = 0.7;
                        } else {
                            landcover = 'rough_pasture';
                            score = 1.0;
                        }
                    }
                    
                    this.landcoverCache.set(cellId, {
                        landcover: landcover,
                        landcover_score: score,
                        source: source
                    });
                });
            }
            
            isNearMajorCity(lat, lng) {
                const cities = [
                    [51.5074, -0.1278], // London
                    [53.4808, -2.2426], // Manchester
                    [52.4862, -1.8904], // Birmingham
                    [55.8642, -4.2518], // Glasgow
                    [55.9533, -3.1883], // Edinburgh
                    [53.3811, -1.4701], // Sheffield
                    [53.7632, -0.3282], // Hull
                    [54.9783, -1.6178]  // Newcastle
                ];
                
                return cities.some(([cityLat, cityLng]) => {
                    const distance = Math.sqrt(Math.pow(lat - cityLat, 2) + Math.pow(lng - cityLng, 2));
                    return distance < 0.2; // Within ~20km
                });
            }
            
            isCoastal(lat, lng) {
                // Simplified coastal detection for UK
                return (lng < -4 || lng > 1.5 || lat < 50.5 || 
                       (lat > 57.5 && lng < -2) || // Scottish highlands
                       (lat > 54 && lng < -3));    // Welsh coast
            }
            
            async recomputeSuitability() {
                if (this.gridCells.size === 0) {
                    throw new Error('No grid cells available. Please refresh data first.');
                }
                
                const results = [];
                let processedCount = 0;
                
                for (const [cellId, cell] of this.gridCells) {
                    const weather = this.weatherCache.get(cellId) || this.getDefaultWeather();
                    const soil = this.soilCache.get(cellId) || this.getDefaultSoil();
                    const landcover = this.landcoverCache.get(cellId) || this.getDefaultLandcover();
                    
                    const suitability = this.computeCellSuitability(weather, soil, landcover);
                    
                    results.push({
                        cellId,
                        cell,
                        weather,
                        soil,
                        landcover,
                        suitability
                    });
                    
                    processedCount++;
                    if (processedCount % 100 === 0) {
                        this.updateStatus(`Computing: ${processedCount}/${this.gridCells.size} cells`);
                        await this.delay(1); // Allow UI updates
                    }
                }
                
                await this.renderSuitabilityLayer(results);
                this.updateStatistics(results);
            }
            
            getDefaultWeather() {
                return {
                    rainfall_72h: 15,
                    temp_max: 12,
                    temp_min: 4,
                    source: 'default'
                };
            }
            
            getDefaultSoil() {
                return {
                    ph: 6.0,
                    drainage: 'moderate',
                    source: 'default'
                };
            }
            
            getDefaultLandcover() {
                return {
                    landcover: 'improved_grassland',
                    landcover_score: 0.5,
                    source: 'default'
                };
            }
            
            computeCellSuitability(weather, soil, landcover) {
                // Land cover score
                const landcoverScore = landcover.landcover_score;
                
                // Soil pH score (Gaussian curve centered at 5.5)
                const phScore = Math.exp(-0.5 * Math.pow((soil.ph - 5.5) / 1.0, 2));
                
                // Drainage score
                const drainageScores = {
                    'well': 1.0,
                    'moderate': 0.8,
                    'imperfect': 0.5,
                    'poor': 0.2,
                    'very_poor': 0.0
                };
                const drainScore = drainageScores[soil.drainage] || 0.5;
                
                // Grazing score (proxy from land cover)
                const grazeScores = {
                    'rough_pasture': 0.9,
                    'acid_grassland': 0.9,
                    'heath': 0.8,
                    'mixed_grass_shrub': 0.7,
                    'improved_grassland': 0.5,
                    'arable': 0.2,
                    'urban': 0.1
                };
                const grazeScore = grazeScores[landcover.landcover] || 0.5;
                
                // Terrain score (simplified - using location as proxy)
                const terrainScore = 0.8; // Placeholder
                
                // Climate score
                const tempMax = weather.temp_max;
                const tempMin = weather.temp_min;
                
                let tmaxScore = 0;
                if (tempMax >= 8 && tempMax <= 18) {
                    tmaxScore = tempMax === 12 ? 1.0 : 0.8;
                } else if (tempMax >= 5 && tempMax <= 22) {
                    tmaxScore = 0.3;
                }
                
                let tminScore = 0;
                if (tempMin >= 0 && tempMin <= 10) {
                    tminScore = tempMin === 6 ? 1.0 : 0.8;
                } else if (tempMin >= -3 && tempMin <= 14) {
                    tminScore = 0.3;
                }
                
                const climateScore = (tmaxScore + tminScore) / 2;
                
                // Base suitability
                const base = 
                    this.weights.landcover * landcoverScore +
                    this.weights.ph * phScore +
                    this.weights.drainage * drainScore +
                    this.weights.grazing * grazeScore +
                    this.weights.terrain * terrainScore +
                    this.weights.climate * climateScore;
                
                // Rainfall adjustments
                const rainfall72h = weather.rainfall_72h;
                let rainBonus = 0;
                let waterlogged = false;
                
                if (rainfall72h >= this.rainThresholds.min && rainfall72h <= this.rainThresholds.max) {
                    rainBonus = 0.05;
                } else if (rainfall72h > this.rainThresholds.max) {
                    waterlogged = drainScore < 0.8;
                }
                
                // Final score
                let final = Math.max(0, Math.min(1, base + rainBonus));
                if (waterlogged) final = Math.min(final, 0.49);
                
                // Color determination
                let color;
                if (final >= 0.70 && rainfall72h >= this.rainThresholds.min && rainfall72h <= this.rainThresholds.max) {
                    color = '#4CAF50'; // Green
                } else if (final >= 0.50 && rainfall72h < this.rainThresholds.min) {
                    color = '#FF9800'; // Orange
                } else {
                    color = '#F44336'; // Red
                }
                
                return {
                    base,
                    final,
                    color,
                    components: {
                        landcover: landcoverScore,
                        ph: phScore,
                        drainage: drainScore,
                        grazing: grazeScore,
                        terrain: terrainScore,
                        climate: climateScore
                    },
                    waterlogged,
                    rainBonus
                };
            }
            
            async renderSuitabilityLayer(results) {
                // Remove existing layer
                if (this.gridLayer) {
                    this.map.removeLayer(this.gridLayer);
                    this.layerControl.removeLayer(this.gridLayer);
                }
                
                const features = results.map(result => ({
                    type: 'Feature',
                    geometry: {
                        type: 'Polygon',
                        coordinates: [result.cell.bounds]
                    },
                    properties: {
                        cellId: result.cellId,
                        suitability: result.suitability,
                        weather: result.weather,
                        soil: result.soil,
                        landcover: result.landcover
                    }
                }));
                
                const geojsonData = {
                    type: 'FeatureCollection',
                    features
                };
                
                this.gridLayer = L.geoJSON(geojsonData, {
                    style: (feature) => ({
                        fillColor: feature.properties.suitability.color,
                        weight: 0.5,
                        opacity: 0.6,
                        color: '#333',
                        fillOpacity: 0.7
                    }),
                    onEachFeature: (feature, layer) => {
                        this.bindCellPopup(layer, feature.properties);
                        
                        layer.on('mouseover', () => {
                            layer.setStyle({
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.9
                            });
                        });
                        
                        layer.on('mouseout', () => {
                            layer.setStyle({
                                weight: 0.5,
                                opacity: 0.6,
                                fillOpacity: 0.7
                            });
                        });
                    }
                });
                
                // Add to map if enabled
                if (document.getElementById('showSuitability').checked) {
                    this.gridLayer.addTo(this.map);
                }
                
                // Add to layer control
                this.layerControl.addOverlay(this.gridLayer, 'Habitat Suitability');
            }
            
            bindCellPopup(layer, properties) {
                const { suitability, weather, soil, landcover } = properties;
                
                const popupContent = `
                    <div style="font-size: 12px; line-height: 1.4; color: #e0e0e0;">
                        <h4 style="margin: 0 0 10px 0; color: #a8d48a;">Habitat Suitability Analysis</h4>
                        
                        <div style="margin-bottom: 10px;">
                            <strong>Final Score:</strong> ${suitability.final.toFixed(3)}<br>
                            <strong>Classification:</strong> <span style="color: ${suitability.color};">‚óè</span>
                            ${suitability.final >= 0.70 ? 'Ideal' : suitability.final >= 0.50 ? 'Good Base' : 'Poor'}
                        </div>
                        
                        <div style="margin-bottom: 10px;">
                            <strong>Component Scores:</strong><br>
                            <small>
                            Land Cover: ${suitability.components.landcover.toFixed(3)} (${landcover.landcover})<br>
                            Soil pH: ${suitability.components.ph.toFixed(3)} (pH ${soil.ph.toFixed(1)})<br>
                            Drainage: ${suitability.components.drainage.toFixed(3)} (${soil.drainage})<br>
                            Grazing: ${suitability.components.grazing.toFixed(3)}<br>
                            Terrain: ${suitability.components.terrain.toFixed(3)}<br>
                            Climate: ${suitability.components.climate.toFixed(3)}
                            </small>
                        </div>
                        
                        <div style="margin-bottom: 10px;">
                            <strong>Recent Weather (72h):</strong><br>
                            <small>
                            Rainfall: ${weather.rainfall_72h.toFixed(1)}mm<br>
                            Max Temp: ${weather.temp_max.toFixed(1)}¬∞C<br>
                            Min Temp: ${weather.temp_min.toFixed(1)}¬∞C
                            </small>
                        </div>
                        
                        ${suitability.waterlogged ? '<div style="color: #ff6b6b; font-weight: bold;">‚ö† Waterlogged conditions detected</div>' : ''}
                        
                        <div style="font-size: 10px; color: #999; margin-top: 8px;">
                            Data: ${weather.source} | ${soil.source} | ${landcover.source}
                        </div>
                    </div>
                `;
                
                layer.bindPopup(popupContent, {
                    maxWidth: 300,
                    className: 'custom-popup'
                });
            }
            
            updateStatistics(results) {
                const avgScore = results.reduce((sum, r) => sum + r.suitability.final, 0) / results.length;
                const idealCount = results.filter(r => r.suitability.color === '#4CAF50').length;
                const goodCount = results.filter(r => r.suitability.color === '#FF9800').length;
                const poorCount = results.filter(r => r.suitability.color === '#F44336').length;
                
                const stats = `Avg: ${avgScore.toFixed(3)} | Ideal: ${idealCount} | Good: ${goodCount} | Poor: ${poorCount}`;
                this.updateStatus(`Analysis complete - ${stats}`);
            }
            
            toggleLayer(layerType, show) {
                switch (layerType) {
                    case 'suitability':
                        if (this.gridLayer) {
                            if (show && !this.map.hasLayer(this.gridLayer)) {
                                this.map.addLayer(this.gridLayer);
                            } else if (!show && this.map.hasLayer(this.gridLayer)) {
                                this.map.removeLayer(this.gridLayer);
                            }
                        }
                        break;
                    case 'landcover':
                    case 'rainfall': 
                    case 'soil':
                        // Placeholder for additional overlay layers
                        console.log(`${layerType} layer toggle:`, show);
                        break;
                }
            }
            
            setLoading(loading) {
                this.isLoading = loading;
                const spinner = document.getElementById('loadingSpinner');
                const button = document.getElementById('refreshData');
                
                if (loading) {
                    spinner.classList.remove('hidden');
                    button.disabled = true;
                    button.style.opacity = '0.5';
                } else {
                    spinner.classList.add('hidden');
                    button.disabled = false;
                    button.style.opacity = '1';
                }
            }
            
            showMessage(message, type) {
                this.hideMessages();
                const elementId = type === 'error' ? 'errorMessage' : 'infoMessage';
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = message;
                    element.classList.remove('hidden');
                }
            }
            
            hideMessages() {
                document.getElementById('errorMessage').classList.add('hidden');
                document.getElementById('infoMessage').classList.add('hidden');
            }
            
            updateStatus(message) {
                const statusElement = document.getElementById('statusText');
                if (statusElement) {
                    statusElement.textContent = message;
                }
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }
        
        // Initialize application
        document.addEventListener('DOMContentLoaded', () => {
            try {
                new LibertyCapsHabitatMap();
            } catch (error) {
                console.error('Failed to initialize application:', error);
                document.getElementById('statusText').textContent = 'Failed to initialize - please refresh page';
            }
        });
    </script>
</body>
</html>
